// Library includes
#include <array>
#include <chrono>
#include <cstdint>
#include <cstring>
#include <memory>
#include <vector>

// STM32 includes
#include "stm32f767xx.h"
#include "stm32f7xx_hal.h"
#include <gpio.h>
#include <main.h>
#include <tim.h>
#include <usart.h>

// Custom includes
#include <quantized_looper/hardware/led.hpp>
#include <quantized_looper/software/led_tasks.hpp>
#include <quantized_looper/utils/logger_singleton.hpp>
#include <reusable_synth/software/task.hpp>

// Helper functions generated by CubeMX
extern "C"
{
    extern void SystemClock_Config();
}

auto logger = LoggerSingleton::get();

// Tap tempo globals
static volatile uint32_t last_tap_time = 0;
static volatile uint32_t cycle_time_ms = 1000; // Default 60 BPM (1 second)
static constexpr uint32_t MIN_CYCLE_TIME = 60;
static constexpr uint32_t MAX_CYCLE_TIME = 3000; // Min 20 BPM

extern UART_HandleTypeDef huart3;

// TODO: move task
// TODO: writer interface not tied to UART
void task_print_logs()
{
    auto log = logger->remove_log();
    if (log.has_value()) {
        const char* msg = log->pBuffer();
        HAL_UART_Transmit(&huart3, (uint8_t*)msg, strlen(msg), 100);
        HAL_UART_Transmit(&huart3, (uint8_t*)"\r\n", 2, 100);
    }
}

// TODO: can creation of this function be automated using CubeMX?
extern "C" void EXTI15_10_IRQHandler(void)
{
    HAL_GPIO_EXTI_IRQHandler(USER_Btn_Pin);
}

// TODO: want external interface for buttons,
extern "C" void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if (GPIO_Pin == USER_Btn_Pin) {
        uint32_t current_time = HAL_GetTick();

        // Debounce: ignore presses within 200ms of last press
        static uint32_t last_press_time = 0;
        if (current_time - last_press_time < 50) {
            return; // Too soon, ignore
        }

        last_press_time = current_time;

        if (last_tap_time > 0) {
            uint32_t time_diff = current_time - last_tap_time;

            // Clamp to reasonable BPM range
            if (time_diff >= MIN_CYCLE_TIME && time_diff <= MAX_CYCLE_TIME) {
                cycle_time_ms = time_diff;
                logger->info("BPM updated");
            }
        }

        last_tap_time = current_time;
    }
}

int main()
{
    HAL_Init();

    SystemClock_Config();

    MX_GPIO_Init();
    HAL_NVIC_SetPriority(EXTI15_10_IRQn, 5, 0); // Lower priority than system
    HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
    MX_TIM3_Init();
    MX_USART3_UART_Init();

    auto led1 = Led<TIM_HandleTypeDef>(
      &htim3, TIM_CHANNEL_3, MX_TIM3_Init, MX_TIM3_DeInit);
    auto led2 = Led<GPIO_TypeDef>(LD2_GPIO_Port, LD2_Pin);
    auto led3 = Led<GPIO_TypeDef>(LD3_GPIO_Port, LD3_Pin);

    using millis = std::chrono::duration<uint32_t, std::milli>;

    auto led1Breathe = LedBreatheAnimation(&led1, millis(cycle_time_ms));
    auto led2Toggle = LedToggleAnimation(&led2);
    auto led3Toggle = LedToggleAnimation(&led3);

    std::array tasks = { TaskControlBlock<millis>(
                           led1Breathe,
                           []() -> millis { return millis(HAL_GetTick()); },
                           millis(20),
                           millis(0)),
                         TaskControlBlock<millis>(
                           led2Toggle,
                           []() -> millis { return millis(HAL_GetTick()); },
                           millis(800),
                           millis(0)),
                         TaskControlBlock<millis>(
                           led3Toggle,
                           []() -> millis { return millis(HAL_GetTick()); },
                           millis(600),
                           millis(0)),
                         TaskControlBlock<millis>(
                           task_print_logs,
                           []() -> millis { return millis(HAL_GetTick()); },
                           millis(100),
                           millis(0)) };

    scheduler(tasks);
}
